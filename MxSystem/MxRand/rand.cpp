/*****************************************************************************
 * rand.c : non-predictible random bytes generator
 *****************************************************************************/
#include "stdafx.h"
#include "MxCommon.h"
#include "MxRand.h"
#include "MxThread.h"
#include "MxFixups.h"

static struct
{
    bool           init;
    unsigned short subi[3];
    MxMutex    lock;
} rand48 = { false, { 0, 0, 0, }, MX_STATIC_MUTEX, };

static void init_rand48 (void)
{
    if (!rand48.init)
    {
		mxRandBytes(rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }
}

/**
 * PRNG uniformly distributed between 0.0 and 1.0 with 48-bits precision.
 *
 * @note Contrary to POSIX drand48(), this function is thread-safe.
 * @warning Series generated by this function are not reproducible.
 * Use erand48() if you need reproducible series.
 *
 * @return a double value within [0.0, 1.0] inclusive
 */
double mxDrand48 (void)
{
    double ret;

	mxMutexLock(&rand48.lock);
    init_rand48 ();
    ret = erand48 (rand48.subi);
	mxMutexUnlock(&rand48.lock);
    return ret;
}

/**
 * PRNG uniformly distributed between 0 and 2^32 - 1.
 *
 * @note Contrary to POSIX lrand48(), this function is thread-safe.
 * @warning Series generated by this function are not reproducible.
 * Use nrand48() if you need reproducible series.
 *
 * @return an integral value within [0.0, 2^32-1] inclusive
 */
long mxLrand48 (void)
{
    long ret;

	mxMutexLock(&rand48.lock);
    init_rand48 ();
    ret = nrand48 (rand48.subi);
	mxMutexUnlock(&rand48.lock);
    return ret;
}

/**
 * PRNG uniformly distributed between -2^32 and 2^32 - 1.
 *
 * @note Contrary to POSIX mrand48(), this function is thread-safe.
 * @warning Series generated by this function are not reproducible.
 * Use jrand48() if you need reproducible series.
 *
 * @return an integral value within [-2^32, 2^32-1] inclusive
 */
long mxMrand48 (void)
{
    long ret;

    mxMutexLock (&rand48.lock);
    init_rand48 ();
    ret = jrand48 (rand48.subi);
    mxMutexUnlock (&rand48.lock);
    return ret;
}
